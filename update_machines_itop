#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
iTop Machine Import Script

This script reads a CSV file containing machine data and updates existing machines in iTop.
It searches for machines by name and updates their information if they are found.
If a machine is not found, it skips to the next one.

CSV file structure:
machineType,name,fqdn,hostname,ip,description,os,os_version,cpu,memory,disk,owner,csamID
"""

import argparse
import csv
import json
import logging
import os
import sys
from datetime import datetime
import requests

# Set up logging
logger = logging.getLogger('itop_machine_import')

def configure_logging():
    """
    Configure logging to output to both console and a log file
    """
    # Create logs directory if it doesn't exist
    log_dir = 'logs'
    if not os.path.exists(log_dir):
        os.makedirs(log_dir)
    
    # Create a timestamped log file
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_file = os.path.join(log_dir, f'itop_import_{timestamp}.log')
    
    # Configure logging
    logger.setLevel(logging.INFO)
    
    # File handler
    file_handler = logging.FileHandler(log_file)
    file_handler.setLevel(logging.INFO)
    
    # Console handler
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    
    # Format
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    # Add handlers to logger
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)
    
    logger.info("Starting iTop machine import")
    logger.info(f"Logging to {log_file}")
    
    return log_file

# Initialize logging at module level
configure_logging()

# --- iTop API Functions ---

def call_itop_api(url, username, password, operation, class_name, key=None, fields=None, version='1.3', verify_ssl=False):
    """
    Helper function to make calls to the iTop REST API.
    
    Args:
        url (str): iTop API URL
        username (str): iTop username
        password (str): iTop password
        operation (str): API operation to perform
        class_name (str): iTop class name
        key: Search key or object ID
        fields (dict): Fields to update
        version (str): API version
        verify_ssl (bool): Whether to verify SSL certificate
    """
    payload = {
        'version': version,
        'auth': {
            'user': username,
            'password': password
        },
        'operation': operation,
        'class': class_name,
    }
    
    if key:
        payload['key'] = key
    
    if fields:
        payload['fields'] = fields
        
    if operation == 'core/update':
        payload['comment'] = 'Updated via CSV import script'
    
    try:
        response = requests.post(url, json=payload, verify=verify_ssl)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logger.error(f"API call failed: {e}")
        return None
    except json.JSONDecodeError:
        logger.error("Failed to decode JSON response from iTop")
        return None

def search_machine_by_name(url, username, password, machine_type, name, ip=None, verify_ssl=False):
    """
    Search for a machine in iTop by name or IP
    
    Args:
        url (str): iTop API URL
        username (str): iTop username
        password (str): iTop password
        machine_type (str): Type of machine ('Server' or 'VirtualMachine')
        name (str): Machine name
        ip (str): Optional IP address to search by
        verify_ssl (bool): Whether to verify SSL certificate
    
    Returns:
        dict: Machine data if found, None otherwise
    """
    logger.info(f"Searching for {machine_type}: {name}" + (f" ({ip})" if ip else ""))
    
    # First try to search by just the name as this is most reliable
    name_query = f"SELECT {machine_type} WHERE name = '{name}'"
    logger.info(f"Executing query: {name_query}")
    
    result = call_itop_api(
        url=url,
        username=username,
        password=password,
        operation='core/get',
        class_name=machine_type,
        key=name_query,
        verify_ssl=verify_ssl
    )
    
    # Log raw API response for debugging
    if result:
        logger.info(f"API response received: {json.dumps(result)[:500]}..." if len(json.dumps(result)) > 500 else json.dumps(result))
        
        # Check the code and message if present
        if 'code' in result:
            logger.info(f"API response code: {result.get('code')}")
        if 'message' in result:
            logger.info(f"API response message: {result.get('message')}")
    else:
        logger.warning("No response received from API call")
    
    # If we found objects, return the first one
    if result and result.get('objects'):
        found_objects = result['objects']
        if found_objects:
            # Get the first matching object
            first_object_id = list(found_objects.keys())[0]
            logger.info(f"Found {machine_type} with ID: {first_object_id}")
            return found_objects[first_object_id]
    
    # If we didn't find by name and IP is provided, try IP separately
    if ip and not result.get('objects'):
        logger.info(f"Trying to search by IP: {ip}")
        # Try several possible field names for IP
        for ip_field in ['managementip', 'ip_address', 'ipaddress', 'primaryip']:
            ip_query = f"SELECT {machine_type} WHERE {ip_field} = '{ip}'"
            logger.info(f"Trying query: {ip_query}")
            
            ip_result = call_itop_api(
                url=url,
                username=username,
                password=password,
                operation='core/get',
                class_name=machine_type,
                key=ip_query,
                verify_ssl=verify_ssl
            )
            
            if ip_result and ip_result.get('objects'):
                found_objects = ip_result['objects']
                if found_objects:
                    # Get the first matching object
                    first_object_id = list(found_objects.keys())[0]
                    logger.info(f"Found {machine_type} with ID: {first_object_id} using field {ip_field}")
                    return found_objects[first_object_id]
    
    logger.warning(f"No {machine_type} found with name '{name}'" + (f" or IP '{ip}'" if ip else ""))
    return None

def update_machine(url, username, password, machine_type, name, fields, verify_ssl=False):
    """
    Update a machine in iTop by name
    
    Args:
        url (str): iTop API URL
        username (str): iTop username
        password (str): iTop password
        machine_type (str): Type of machine ('Server' or 'VirtualMachine')
        name (str): Name of the machine to update
        fields (dict): Fields to update
        verify_ssl (bool): Whether to verify SSL certificate
            
    Returns:
        bool: True if successful, False otherwise
    """
    logger.info(f"Updating {machine_type} '{name}' with fields: {fields}")
    
    # Use OQL query to identify machine by name
    key = f"SELECT {machine_type} WHERE name = '{name}'"
    
    result = call_itop_api(
        url=url,
        username=username,
        password=password,
        operation='core/update',
        class_name=machine_type,
        key=key,
        fields=fields,
        verify_ssl=verify_ssl
    )
    
    if result and result.get('message') == 'Object updated':
        logger.info(f"Successfully updated {machine_type} '{name}'")
        return True
    elif result is not None:
        error_msg = result.get('message', 'Unknown error')
        logger.error(f"Error updating {machine_type} '{name}': {error_msg}")
        return False
    else:
        logger.error(f"Failed to update {machine_type} '{name}': API call failed")
        return False


def process_csv(file_path, url, username, password, verify_ssl=False):
    """
    Process the CSV file and update machines in iTop
    
    Args:
        file_path (str): Path to the CSV file
        url (str): iTop API URL
        username (str): iTop username
        password (str): iTop password
        verify_ssl (bool): Whether to verify SSL certificate
        
    Returns:
        tuple: (processed, updated, skipped) counts
    """
    processed = 0
    updated = 0
    skipped = 0
    
    try:
        with open(file_path, 'r', encoding='utf-8-sig') as f:
            reader = csv.DictReader(f)
            
            line_num = 1  # Start line number after header
            
            for row in reader:
                processed += 1
                
                machine_type = row.get('machineType', '').strip()
                name = row.get('name', '').strip()
                ip = row.get('ip', '').strip()
                
                logger.info(f"\nProcessing line {line_num}: {machine_type}='{name}', IP='{ip}'")
                line_num += 1
                
                if not name:
                    logger.warning(f"Skipping: Missing machine name")
                    skipped += 1
                    continue
                
                if not machine_type:
                    logger.warning(f"Skipping '{name}': Missing machine type")
                    skipped += 1
                    continue
                
                # Validate machine type
                if machine_type not in ['Server', 'VirtualMachine']:
                    logger.warning(f"Skipping '{name}': Invalid machine type '{machine_type}'")
                    skipped += 1
                    continue
                
                # Optional DNS verification could be added here, similar to working example
                                
                # Search for the machine in iTop by name and IP if available
                machine = search_machine_by_name(url, username, password, machine_type, name, ip, verify_ssl)
                
                if not machine:
                    logger.warning(f"Machine '{name}' not found in iTop. Skipping update.")
                    skipped += 1
                    continue
                
                logger.info(f"Machine '{name}' found in iTop. Proceeding to update.")
                
                # Prepare fields to update
                fields = {}
                
                # Handle IP field
                if ip:
                    # The IP field in iTop is called 'managementip' for both VirtualMachine and Server
                    fields['managementip'] = ip
                
                # Base field mapping - common for all machine types
                field_mapping = {
                    'fqdn': 'fqdn',
                    'hostname': 'hostname',
                    'os': 'os_family',
                    'os_version': 'os_version',
                    'cpu': 'cpu',
                    'memory': 'ram',
                    'owner': 'owner_name',  # May need to be 'owner_id' depending on iTop
                    'csamID': 'csam_id'
                }
                
                # Handle type-specific field mappings
                if machine_type == 'VirtualMachine':
                    # For VirtualMachine, map description to notes and include disk field
                    if 'description' in row and row['description'].strip():
                        fields['notes'] = row['description'].strip()
                    
                    # Only process disk field for VirtualMachine
                    if 'disk' in row and row['disk'].strip():
                        fields['disk_space'] = row['disk'].strip()
                else:  # Server type
                    # For Server, map description to description
                    if 'description' in row and row['description'].strip():
                        fields['description'] = row['description'].strip()
                    
                    # Ignore disk field for Server type
                
                # Add other non-empty fields to the update
                for csv_field, itop_field in field_mapping.items():
                    if csv_field in row and row[csv_field].strip():
                        fields[itop_field] = row[csv_field].strip()
                
                # Update the machine in iTop
                if fields:
                    # Log fields being updated
                    logger.info(f"Setting fields: {', '.join([f'{k}={v}' for k, v in fields.items()])}")
                    
                    # Use name instead of ID for updates
                    success = update_machine(url, username, password, machine_type, name, fields, verify_ssl)
                    if success:
                        updated += 1
                        logger.info(f"Successfully processed and updated '{name}'")
                    else:
                        skipped += 1
                        logger.warning(f"Failed to update '{name}'. Check update function and API response.")
                else:
                    logger.warning(f"No fields to update for '{name}'")
                    skipped += 1
    
    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
    except Exception as e:
        logger.error(f"Error processing CSV: {e}")
    
    return processed, updated, skipped


def main():
    """
    Main entry point
    """
    parser = argparse.ArgumentParser(description='Import machine data from CSV to iTop')
    parser.add_argument('csv_file', help='Path to the CSV file')
    parser.add_argument('--url', required=True, help='iTop REST API URL (e.g., https://itop.example.com/webservices/rest.php)')
    parser.add_argument('--user', required=True, help='iTop username')
    parser.add_argument('--password', required=True, help='iTop password')
    parser.add_argument('--verify-ssl', action='store_true', dest='verify_ssl',
                        help='Enable SSL certificate verification (disabled by default)')
    
    args = parser.parse_args()
    
    # Check if the CSV file exists
    if not os.path.isfile(args.csv_file):
        logger.error(f"CSV file not found: {args.csv_file}")
        return 1
    
    try:
        # Display SSL verification status
        if args.verify_ssl:
            logger.info("SSL certificate verification is enabled")
        else:
            logger.info("SSL certificate verification is disabled")
            
        # Process the CSV file
        processed, updated, skipped = process_csv(
            file_path=args.csv_file,
            url=args.url,
            username=args.user,
            password=args.password,
            verify_ssl=args.verify_ssl
        )
        
        # Print summary
        logger.info("\nSummary:")
        logger.info(f"Processed: {processed}")
        logger.info(f"Updated: {updated}")
        logger.info(f"Skipped: {skipped}")
        
        return 0
    except Exception as e:
        logger.exception(f"An error occurred: {e}")
        return 1


if __name__ == "__main__":
    main()

