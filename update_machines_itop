#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
iTop Machine Import Script

This script reads a CSV file containing machine data and updates existing machines in iTop.
It searches for machines by name and updates their information if they are found.
If a machine is not found, it skips to the next one.

CSV file structure:
machineType,name,fqdn,hostname,ip,description,os,os_version,cpu,memory,disk,owner,csamID
"""

import csv
import sys
import requests
import json
import logging
import argparse
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(f"itop_import_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# --- iTop API Functions ---

def call_itop_api(url, username, password, operation, class_name, key=None, fields=None, version='1.3', verify_ssl=False):
    """
    Helper function to make calls to the iTop REST API.
    
    Args:
        url (str): iTop API URL
        username (str): iTop username
        password (str): iTop password
        operation (str): API operation to perform
        class_name (str): iTop class name
        key: Search key or object ID
        fields (dict): Fields to update
        version (str): API version
        verify_ssl (bool): Whether to verify SSL certificate
    """
    payload = {
        'version': version,
        'auth': {
            'user': username,
            'password': password
        },
        'operation': operation,
        'class': class_name,
    }
    
    if key:
        payload['key'] = key
    
    if fields:
        payload['fields'] = fields
        
    if operation == 'core/update':
        payload['comment'] = 'Updated via CSV import script'
    
    try:
        response = requests.post(url, json=payload, verify=verify_ssl)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logger.error(f"API call failed: {e}")
        return None
    except json.JSONDecodeError:
        logger.error("Failed to decode JSON response from iTop")
        return None

def search_machine_by_name(url, username, password, machine_type, name, ip=None, verify_ssl=False):
    """
    Search for a machine in iTop by name or IP
    
    Args:
        url (str): iTop API URL
        username (str): iTop username
        password (str): iTop password
        machine_type (str): Type of machine ('Server' or 'VirtualMachine')
        name (str): Machine name
        ip (str): Optional IP address to search by
        verify_ssl (bool): Whether to verify SSL certificate
    
    Returns:
        dict: Machine data if found, None otherwise
    """
    logger.info(f"Searching for {machine_type}: {name}" + (f" ({ip})" if ip else ""))
    
    # Create an OQL query to search by name, and also by IP if provided
    if ip:
        # Assume the IP field name in iTop is 'ip_address' for VirtualMachine and 'ipaddress' for Server
        ip_field = 'ip_address' if machine_type == 'VirtualMachine' else 'ipaddress'
        oql_query = f"SELECT {machine_type} WHERE name = '{name}' OR {ip_field} = '{ip}'"
    else:
        oql_query = f"SELECT {machine_type} WHERE name = '{name}'"
    
    result = call_itop_api(
        url=url,
        username=username,
        password=password,
        operation='core/get',
        class_name=machine_type,
        key=oql_query,
        verify_ssl=verify_ssl
    )
    
    if result and result.get('objects'):
        found_objects = result['objects']
        if found_objects:
            # Get the first matching object
            first_object_id = list(found_objects.keys())[0]
            logger.info(f"Found {machine_type} with ID: {first_object_id}")
            return found_objects[first_object_id]
    
    logger.info(f"No {machine_type} found with name '{name}'" + (f" or IP '{ip}'" if ip else ""))
    return None

def update_machine(url, username, password, machine_type, name, fields, verify_ssl=False):
    """
    Update a machine in iTop by name
    
    Args:
        url (str): iTop API URL
        username (str): iTop username
        password (str): iTop password
        machine_type (str): Type of machine ('Server' or 'VirtualMachine')
        name (str): Name of the machine to update
        fields (dict): Fields to update
        verify_ssl (bool): Whether to verify SSL certificate
            
    Returns:
        bool: True if successful, False otherwise
    """
    logger.info(f"Updating {machine_type} '{name}' with fields: {fields}")
    
    # Use OQL query to identify machine by name
    key = f"SELECT {machine_type} WHERE name = '{name}'"
    
    result = call_itop_api(
        url=url,
        username=username,
        password=password,
        operation='core/update',
        class_name=machine_type,
        key=key,
        fields=fields,
        verify_ssl=verify_ssl
    )
    
    if result and result.get('message') == 'Object updated':
        logger.info(f"Successfully updated {machine_type} '{name}'")
        return True
    elif result is not None:
        error_msg = result.get('message', 'Unknown error')
        logger.error(f"Error updating {machine_type} '{name}': {error_msg}")
        return False
    else:
        logger.error(f"Failed to update {machine_type} '{name}': API call failed")
        return False


def process_csv(file_path, url, username, password, verify_ssl=False):
    """
    Process the CSV file and update machines in iTop
    
    Args:
        file_path (str): Path to the CSV file
        url (str): iTop API URL
        username (str): iTop username
        password (str): iTop password
        verify_ssl (bool): Whether to verify SSL certificate
        
    Returns:
        tuple: (processed, updated, skipped) counts
    """
    processed = 0
    updated = 0
    skipped = 0
    
    try:
        with open(file_path, 'r', encoding='utf-8-sig') as f:
            reader = csv.DictReader(f)
            
            line_num = 1  # Start line number after header
            
            for row in reader:
                processed += 1
                
                machine_type = row.get('machineType', '').strip()
                name = row.get('name', '').strip()
                ip = row.get('ip', '').strip()
                
                logger.info(f"\nProcessing line {line_num}: {machine_type}='{name}', IP='{ip}'")
                line_num += 1
                
                if not name:
                    logger.warning(f"Skipping: Missing machine name")
                    skipped += 1
                    continue
                
                if not machine_type:
                    logger.warning(f"Skipping '{name}': Missing machine type")
                    skipped += 1
                    continue
                
                # Validate machine type
                if machine_type not in ['Server', 'VirtualMachine']:
                    logger.warning(f"Skipping '{name}': Invalid machine type '{machine_type}'")
                    skipped += 1
                    continue
                
                # Optional DNS verification could be added here, similar to working example
                                
                # Search for the machine in iTop by name and IP if available
                machine = search_machine_by_name(url, username, password, machine_type, name, ip, verify_ssl)
                
                if not machine:
                    logger.warning(f"Machine '{name}' not found in iTop. Skipping update.")
                    skipped += 1
                    continue
                
                logger.info(f"Machine '{name}' found in iTop. Proceeding to update.")
                
                # Prepare fields to update
                fields = {}
                
                # Handle IP field properly based on machine type
                if ip:
                    ip_field = 'ip_address' if machine_type == 'VirtualMachine' else 'ipaddress'
                    fields[ip_field] = ip
                
                # Base field mapping - common for all machine types
                field_mapping = {
                    'fqdn': 'fqdn',
                    'hostname': 'hostname',
                    'os': 'os_family',
                    'os_version': 'os_version',
                    'cpu': 'cpu',
                    'memory': 'ram',
                    'owner': 'owner_name',  # May need to be 'owner_id' depending on iTop
                    'csamID': 'csam_id'
                }
                
                # Handle type-specific field mappings
                if machine_type == 'VirtualMachine':
                    # For VirtualMachine, map description to notes and include disk field
                    if 'description' in row and row['description'].strip():
                        fields['notes'] = row['description'].strip()
                    
                    # Only process disk field for VirtualMachine
                    if 'disk' in row and row['disk'].strip():
                        fields['disk_space'] = row['disk'].strip()
                else:  # Server type
                    # For Server, map description to description
                    if 'description' in row and row['description'].strip():
                        fields['description'] = row['description'].strip()
                    
                    # Ignore disk field for Server type
                
                # Add other non-empty fields to the update
                for csv_field, itop_field in field_mapping.items():
                    if csv_field in row and row[csv_field].strip():
                        fields[itop_field] = row[csv_field].strip()
                
                # Update the machine in iTop
                if fields:
                    # Log fields being updated
                    logger.info(f"Setting fields: {', '.join([f'{k}="{v}"' for k, v in fields.items()])}")
                    
                    # Use name instead of ID for updates
                    success = update_machine(url, username, password, machine_type, name, fields, verify_ssl)
                    if success:
                        updated += 1
                        logger.info(f"Successfully processed and updated '{name}'")
                    else:
                        skipped += 1
                        logger.warning(f"Failed to update '{name}'. Check update function and API response.")
                else:
                    logger.warning(f"No fields to update for '{name}'")
                    skipped += 1
    
    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
    except Exception as e:
        logger.error(f"Error processing CSV: {e}")
    
    return processed, updated, skipped


def main():
    """
    Main entry point
    """
    parser = argparse.ArgumentParser(description='Import machine data from CSV to iTop')
    parser.add_argument('csv_file', help='Path to the CSV file')
    parser.add_argument('--url', required=True, help='iTop REST API URL (e.g., https://itop.example.com/webservices/rest.php)')
    parser.add_argument('--user', required=True, help='iTop username')
    parser.add_argument('--password', required=True, help='iTop password')
    parser.add_argument('--verify-ssl', action='store_true', dest='verify_ssl',
                        help='Enable SSL certificate verification (disabled by default)')
    
    args = parser.parse_args()
    
    configure_logging()
    
    # Check if the CSV file exists
    if not os.path.isfile(args.csv_file):
        logger.error(f"CSV file not found: {args.csv_file}")
        return 1
    
    try:
        # Display SSL verification status
        if args.verify_ssl:
            logger.info("SSL certificate verification is enabled")
        else:
            logger.info("SSL certificate verification is disabled")
            
        # Process the CSV file
        processed, updated, skipped = process_csv(
            file_path=args.csv_file,
            url=args.url,
            username=args.user,
            password=args.password,
            verify_ssl=args.verify_ssl
        )
        
        # Print summary
        logger.info("\nSummary:")
        logger.info(f"Processed: {processed}")
        logger.info(f"Updated: {updated}")
        logger.info(f"Skipped: {skipped}")
        
        return 0
    except Exception as e:
        logger.exception(f"An error occurred: {e}")
        return 1


if __name__ == "__main__":
    main()
